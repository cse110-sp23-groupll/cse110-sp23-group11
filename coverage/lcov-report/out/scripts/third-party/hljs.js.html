
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for out/scripts/third-party/hljs.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../prettify.css" />
    <link rel="stylesheet" href="../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../index.html">All files</a> / <a href="index.html">out/scripts/third-party</a> hljs.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/517</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/446</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/157</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input oninput="onInput()" type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">var hljs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){"use strict";var e=<span class="cstat-no" title="statement not covered" >{exports:{}};</span>function <span class="fstat-no" title="function not covered" >t(</span>n){<span class="cstat-no" title="statement not covered" >return n instanceof Map?n.clear=n.delete=n.set=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("map is read-only")}</span>:n instanceof Set&amp;&amp;(n.add=n.clear=n.delete=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("set is read-only")}</span>),Object.freeze(n),Object.getOwnPropertyNames(n).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e=n[e];<span class="cstat-no" title="statement not covered" >"</span>object"!=typeof e||Object.isFrozen(e)||t(e)}</span>),n}<span class="cstat-no" title="statement not covered" ></span>e.exports=t,e.exports.default=t;v</span>ar z=<span class="cstat-no" title="statement not covered" >e.exports;</span>class D{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >void 0===e.data&amp;&amp;(e.data={}),this.data=e.data,this.isMatchIgnored=!1}<span class="fstat-no" title="function not covered" ></span>ig</span>noreMatch(){<span class="cstat-no" title="statement not covered" >this.isMatchIgnored=!0}</span>}function <span class="fstat-no" title="function not covered" >n(</span>e){<span class="cstat-no" title="statement not covered" >return e.replace(/&amp;/g,"&amp;amp;").replace(/&lt;/g,"&amp;lt;").replace(/&gt;/g,"&amp;gt;").replace(/"/g,"&amp;quot;").replace(/'/g,"&amp;#x27;")}</span>function <span class="fstat-no" title="function not covered" >l(</span>e,...n){const t=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>for(const a in e)<span class="cstat-no" title="statement not covered" >t[a]=e[a];<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(const n in e)<span class="cstat-no" title="statement not covered" >t[n]=e[n]}</span></span>),t}</span>const a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >!!e.kind;</span></span>class T{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,n){<span class="cstat-no" title="statement not covered" >this.buffer="",this.classPrefix=n.classPrefix,e.walk(this)}<span class="fstat-no" title="function not covered" ></span>ad</span>dText(e){<span class="cstat-no" title="statement not covered" >this.buffer+=n(e)}<span class="fstat-no" title="function not covered" ></span>op</span>enNode(n){<span class="cstat-no" title="statement not covered" >if(a(n)){let e=<span class="cstat-no" title="statement not covered" >n.kind;<span class="cstat-no" title="statement not covered" ></span>e=n.sublanguage?"language-"+e:(<span class="fstat-no" title="function not covered" >(e</span>,{prefix:n})=&gt;{<span class="cstat-no" title="statement not covered" >if(e.includes(".")){const t=<span class="cstat-no" title="statement not covered" >e.split(".");<span class="cstat-no" title="statement not covered" ></span>return[""+n+t.shift(),...t.map(<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >""+e+"_".repeat(n+1))</span>].join(" ")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn""+n+e}</span>)(e,{prefix:this.classPrefix}),this.span(e)}</span>}<span class="fstat-no" title="function not covered" ></span>cl</span>oseNode(e){<span class="cstat-no" title="statement not covered" >a(e)&amp;&amp;(this.buffer+="&lt;/span&gt;")}<span class="fstat-no" title="function not covered" ></span>va</span>lue(){<span class="cstat-no" title="statement not covered" >return this.buffer}<span class="fstat-no" title="function not covered" ></span>sp</span>an(e){<span class="cstat-no" title="statement not covered" >this.buffer+=`&lt;span class="${e}"&gt;`}</span>}class i{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.rootNode={children:[]},this.stack=[this.rootNode]}<span class="fstat-no" title="function not covered" ></span>ge</span>t top(){<span class="cstat-no" title="statement not covered" >return this.stack[this.stack.length-1]}<span class="fstat-no" title="function not covered" ></span>ge</span>t root(){<span class="cstat-no" title="statement not covered" >return this.rootNode}<span class="fstat-no" title="function not covered" ></span>ad</span>d(e){<span class="cstat-no" title="statement not covered" >this.top.children.push(e)}<span class="fstat-no" title="function not covered" ></span>op</span>enNode(e){<span class="cstat-no" title="statement not covered" >e={kind:e,children:[]};<span class="cstat-no" title="statement not covered" >t</span>his.add(e),this.stack.push(e)}<span class="fstat-no" title="function not covered" ></span>cl</span>oseNode(){<span class="cstat-no" title="statement not covered" >if(1&lt;this.stack.length)<span class="cstat-no" title="statement not covered" >return this.stack.pop()}<span class="fstat-no" title="function not covered" ></span></span>cl</span>oseAllNodes(){<span class="cstat-no" title="statement not covered" >for(;this.closeNode(););}<span class="fstat-no" title="function not covered" ></span>to</span>JSON(){<span class="cstat-no" title="statement not covered" >return JSON.stringify(this.rootNode,null,4)}<span class="fstat-no" title="function not covered" ></span>wa</span>lk(e){<span class="cstat-no" title="statement not covered" >return this.constructor._walk(e,this.rootNode)}<span class="fstat-no" title="function not covered" ></span>st</span>atic _walk(n,e){<span class="cstat-no" title="statement not covered" >return"string"==typeof e?n.addText(e):e.children&amp;&amp;(n.openNode(e),e.children.forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >this._walk(n,e))</span>,n.closeNode(e)),n}<span class="fstat-no" title="function not covered" ></span>st</span>atic _collapse(e){<span class="cstat-no" title="statement not covered" >"string"!=typeof e&amp;&amp;e.children&amp;&amp;(e.children.every(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"string"==typeof e)</span>?e.children=[e.children.join("")]:e.children.forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >i._collapse(e)}</span>))}</span>}class L extends i{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >super(),this.options=e}<span class="fstat-no" title="function not covered" ></span>ad</span>dKeyword(e,n){<span class="cstat-no" title="statement not covered" >""!==e&amp;&amp;(this.openNode(n),this.addText(e),this.closeNode())}<span class="fstat-no" title="function not covered" ></span>ad</span>dText(e){<span class="cstat-no" title="statement not covered" >""!==e&amp;&amp;this.add(e)}<span class="fstat-no" title="function not covered" ></span>ad</span>dSublanguage(e,n){const t=<span class="cstat-no" title="statement not covered" >e.root;<span class="cstat-no" title="statement not covered" ></span>t.kind=n,t.sublanguage=!0,this.add(t)}<span class="fstat-no" title="function not covered" ></span>to</span>HTML(){const e=<span class="cstat-no" title="statement not covered" >new T(this,this.options);<span class="cstat-no" title="statement not covered" ></span>return e.value()}<span class="fstat-no" title="function not covered" ></span>fi</span>nalize(){<span class="cstat-no" title="statement not covered" >return!0}</span>}function <span class="fstat-no" title="function not covered" >c(</span>e){<span class="cstat-no" title="statement not covered" >return e?"string"==typeof e?e:e.source:null}</span>function <span class="fstat-no" title="function not covered" >k(</span>e){<span class="cstat-no" title="statement not covered" >return O("(?=",e,")")}</span>function <span class="fstat-no" title="function not covered" >O(</span>...e){<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >c(e))</span>.join("")}</span>function <span class="fstat-no" title="function not covered" >d(</span>...e){var n,t=<span class="cstat-no" title="statement not covered" >"object"==typeof(n=(t=e)[t.length-1])&amp;&amp;n.constructor===Object?(t.splice(t.length-1,1),n):{};<span class="cstat-no" title="statement not covered" ></span>return"("+(t.capture?"":"?:")+e.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >c(e))</span>.join("|")+")"}</span>function <span class="fstat-no" title="function not covered" >u(</span>e){<span class="cstat-no" title="statement not covered" >return new RegExp(e.toString()+"|").exec("").length-1}</span>const I=<span class="cstat-no" title="statement not covered" >/\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;</span>function <span class="fstat-no" title="function not covered" >g(</span>e,{joinWith:n}){let r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return e.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;{var n=<span class="cstat-no" title="statement not covered" >r+=1;</span>let t=<span class="cstat-no" title="statement not covered" >c(e),</span>a=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(;0&lt;t.length;){var i=<span class="cstat-no" title="statement not covered" >I.exec(t);<span class="cstat-no" title="statement not covered" ></span>if(!i){<span class="cstat-no" title="statement not covered" >a+=t;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>a</span>+=t.substring(0,i.index),t=t.substring(i.index+i[0].length),"\\"===i[0][0]&amp;&amp;i[1]?a+="\\"+String(Number(i[1])+n):(a+=i[0],"("===i[0]&amp;&amp;r++)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>).map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >`(${e})`)</span>.join(n)}</span>function <span class="fstat-no" title="function not covered" >r(</span>e,n,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const a=<span class="cstat-no" title="statement not covered" >l({scope:"comment",begin:e,end:n,contains:[]},t);<span class="cstat-no" title="statement not covered" ></span>return a.contains.push({scope:"doctag",begin:"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",end:/(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,excludeBegin:!0,relevance:0}),e=d("I","a","is","so","us","to","at","if","in","it","on",/[A-Za-z]+['](d|ve|re|ll|t|s|n)/,/[A-Za-z]+[-][a-z]+/,/[A-Za-z][a-z]{2,}/),a.contains.push({begin:O(/[ ]+/,"(",e,/[.]?[:]?([.][ ]|[ ])/,"){3}")}),a}</span>var e=<span class="cstat-no" title="statement not covered" >"[a-zA-Z]\\w*",</span>s=<span class="cstat-no" title="statement not covered" >"[a-zA-Z_]\\w*",</span>o=<span class="cstat-no" title="statement not covered" >"\\b\\d+(\\.\\d+)?",</span>b=<span class="cstat-no" title="statement not covered" >"(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",</span>h=<span class="cstat-no" title="statement not covered" >"\\b(0b[01]+)",</span>p=<span class="cstat-no" title="statement not covered" >{begin:"\\\\[\\s\\S]",relevance:0},</span>m=<span class="cstat-no" title="statement not covered" >{scope:"string",begin:"'",end:"'",illegal:"\\n",contains:[p]},</span>f=<span class="cstat-no" title="statement not covered" >{scope:"string",begin:'"',end:'"',illegal:"\\n",contains:[p]},</span>E=<span class="cstat-no" title="statement not covered" >r("//","$"),</span>v=<span class="cstat-no" title="statement not covered" >r("/\\*","\\*/"),</span>w=<span class="cstat-no" title="statement not covered" >r("#","$"),</span>y=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,MATCH_NOTHING_RE:/\b\B/,IDENT_RE:e,UNDERSCORE_IDENT_RE:s,NUMBER_RE:o,C_NUMBER_RE:b,BINARY_NUMBER_RE:h,RE_STARTERS_RE:"!|!=|!==|%|%=|&amp;|&amp;&amp;|&amp;=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|&lt;&lt;|&lt;&lt;=|&lt;=|&lt;|===|==|=|&gt;&gt;&gt;=|&gt;&gt;=|&gt;=|&gt;&gt;&gt;|&gt;&gt;|&gt;|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",SHEBANG:<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{var n=<span class="cstat-no" title="statement not covered" >/^#![ ]*\//;<span class="cstat-no" title="statement not covered" ></span>return e.binary&amp;&amp;(e.begin=O(n,/.*\b/,e.binary,/\b.*/)),l({scope:"meta",begin:n,end:/$/,relevance:0,"on:begin":<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >0!==e.index&amp;&amp;n.ignoreMatch()}</span>},e)}</span>,BACKSLASH_ESCAPE:p,APOS_STRING_MODE:m,QUOTE_STRING_MODE:f,PHRASAL_WORDS_MODE:{begin:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/},COMMENT:r,C_LINE_COMMENT_MODE:E,C_BLOCK_COMMENT_MODE:v,HASH_COMMENT_MODE:w,NUMBER_MODE:{scope:"number",begin:o,relevance:0},C_NUMBER_MODE:{scope:"number",begin:b,relevance:0},BINARY_NUMBER_MODE:{scope:"number",begin:h,relevance:0},REGEXP_MODE:{begin:/(?=\/[^/\n]*\/)/,contains:[{scope:"regexp",begin:/\//,end:/\/[gimuy]*/,illegal:/\n/,contains:[p,{begin:/\[/,end:/\]/,relevance:0,contains:[p]}]}]},TITLE_MODE:{scope:"title",begin:e,relevance:0},UNDERSCORE_TITLE_MODE:{scope:"title",begin:s,relevance:0},METHOD_GUARD:{begin:"\\.\\s*"+s,relevance:0},END_SAME_AS_BEGIN:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Object.assign(e,{"on:begin":<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >n.data._beginMatch=e[1]}</span>,"on:end":<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >n.data._beginMatch!==e[1]&amp;&amp;n.ignoreMatch()}</span>})}</span>});</span>function <span class="fstat-no" title="function not covered" >$(</span>e,n){<span class="cstat-no" title="statement not covered" >"."===e.input[e.index-1]&amp;&amp;n.ignoreMatch()}</span>function <span class="fstat-no" title="function not covered" >P(</span>e,n){<span class="cstat-no" title="statement not covered" >void 0!==e.className&amp;&amp;(e.scope=e.className,delete e.className)}</span>function <span class="fstat-no" title="function not covered" >U(</span>e,n){<span class="cstat-no" title="statement not covered" >n&amp;&amp;e.beginKeywords&amp;&amp;(e.begin="\\b("+e.beginKeywords.split(" ").join("|")+")(?!\\.)(?=\\b|\\s)",e.__beforeBegin=$,e.keywords=e.keywords||e.beginKeywords,delete e.beginKeywords,void 0===e.relevance&amp;&amp;(e.relevance=0))}</span>function <span class="fstat-no" title="function not covered" >H(</span>e,n){<span class="cstat-no" title="statement not covered" >Array.isArray(e.illegal)&amp;&amp;(e.illegal=d(...e.illegal))}</span>function <span class="fstat-no" title="function not covered" >Z(</span>e,n){<span class="cstat-no" title="statement not covered" >if(e.match){<span class="cstat-no" title="statement not covered" >if(e.begin||e.end)<span class="cstat-no" title="statement not covered" >throw new Error("begin &amp; end are not supported with match");<span class="cstat-no" title="statement not covered" >e</span></span>.begin=e.match,delete e.match}</span>}</span>function <span class="fstat-no" title="function not covered" >G(</span>e,n){<span class="cstat-no" title="statement not covered" >void 0===e.relevance&amp;&amp;(e.relevance=1)}</span>const K=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >if(n.beforeMatch){<span class="cstat-no" title="statement not covered" >if(n.starts)<span class="cstat-no" title="statement not covered" >throw new Error("beforeMatch cannot be used with starts");c</span></span>onst t=<span class="cstat-no" title="statement not covered" >Object.assign({},n);<span class="cstat-no" title="statement not covered" ></span>Object.keys(n).forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >delete n[e]}</span>),n.keywords=t.keywords,n.begin=O(t.beforeMatch,k(t.begin)),n.starts={relevance:0,contains:[Object.assign(t,{endsParent:!0})]},n.relevance=0,delete t.beforeMatch}</span>}</span>,</span>X=<span class="cstat-no" title="statement not covered" >["of","and","for","in","not","or","if","then","parent","list","value"],</span>W=<span class="cstat-no" title="statement not covered" >"keyword";</span>function <span class="fstat-no" title="function not covered" >_(</span>n,t,e=<span class="branch-0 cbranch-no" title="branch not covered" >W)</span>{const a=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>return"string"==typeof n?i(e,n.split(" ")):Array.isArray(n)?i(e,n):Object.keys(n).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >Object.assign(a,_(n[e],t,e))}</span>),a;f</span>unction <span class="fstat-no" title="function not covered" >i(</span>n,e){<span class="cstat-no" title="statement not covered" >(e=t?e.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.toLowerCase())</span>:e).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e=e.split("|");<span class="cstat-no" title="statement not covered" >a</span>[e[0]]=[n,<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >return Number(n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn <span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return X.includes(e.toLowerCase())}</span>(e)?0:1}</span>(e[0],e[1])]}</span>)}</span>}const N=<span class="cstat-no" title="statement not covered" >{},</span>j=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >console.error(e)}</span>,</span>x=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,...n)=&gt;{<span class="cstat-no" title="statement not covered" >console.log("WARN: "+e,...n)}</span>,</span>A=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >N[e+"/"+n]||(console.log(`Deprecated as of ${e}. `+n),N[e+"/"+n]=!0)}</span>,</span>S=<span class="cstat-no" title="statement not covered" >new Error;</span>function <span class="fstat-no" title="function not covered" >M(</span>e,n,{key:t}){let a=<span class="cstat-no" title="statement not covered" >0;</span>var i=<span class="cstat-no" title="statement not covered" >e[t];</span>const r=<span class="cstat-no" title="statement not covered" >{},</span>s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >1;</span>e&lt;=n.length;e++)<span class="cstat-no" title="statement not covered" >s[e+a]=i[e],r[e+a]=!0,a+=u(n[e-1]);<span class="cstat-no" title="statement not covered" >e</span></span>[t]=s,e[t]._emit=r,e[t]._multi=!0}</span>function <span class="fstat-no" title="function not covered" >q(</span>e){<span class="cstat-no" title="statement not covered" >(n=e).scope&amp;&amp;"object"==typeof n.scope&amp;&amp;null!==n.scope&amp;&amp;(n.beginScope=n.scope,delete n.scope),"string"==typeof e.beginScope&amp;&amp;(e.beginScope={_wrap:e.beginScope}),"string"==typeof e.endScope&amp;&amp;(e.endScope={_wrap:e.endScope});v</span>ar n=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(n.begin)){<span class="cstat-no" title="statement not covered" >if(n.skip||n.excludeBegin||n.returnBegin)<span class="cstat-no" title="statement not covered" >throw j("skip, excludeBegin, returnBegin not compatible with beginScope: {}"),S;<span class="cstat-no" title="statement not covered" >i</span></span>f("object"!=typeof n.beginScope||null===n.beginScope)<span class="cstat-no" title="statement not covered" >throw j("beginScope must be object"),S;<span class="cstat-no" title="statement not covered" >M</span></span>(n,n.begin,{key:"beginScope"}),n.begin=g(n.begin,{joinWith:""})}<span class="cstat-no" title="statement not covered" ></span>n</span>=e;<span class="cstat-no" title="statement not covered" >i</span>f(Array.isArray(n.end)){<span class="cstat-no" title="statement not covered" >if(n.skip||n.excludeEnd||n.returnEnd)<span class="cstat-no" title="statement not covered" >throw j("skip, excludeEnd, returnEnd not compatible with endScope: {}"),S;<span class="cstat-no" title="statement not covered" >i</span></span>f("object"!=typeof n.endScope||null===n.endScope)<span class="cstat-no" title="statement not covered" >throw j("endScope must be object"),S;<span class="cstat-no" title="statement not covered" >M</span></span>(n,n.end,{key:"endScope"}),n.end=g(n.end,{joinWith:""})}</span>}</span>function <span class="fstat-no" title="function not covered" >Q(</span>r){function <span class="fstat-no" title="function not covered" >s(</span>e,n){<span class="cstat-no" title="statement not covered" >return new RegExp(c(e),"m"+(r.case_insensitive?"i":"")+(n?"g":""))}</span>class n{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.matchIndexes={},this.regexes=[],this.matchAt=1,this.position=0}<span class="fstat-no" title="function not covered" ></span>ad</span>dRule(e,n){<span class="cstat-no" title="statement not covered" >n.position=this.position++,this.matchIndexes[this.matchAt]=n,this.regexes.push([n,e]),this.matchAt+=u(e)+1}<span class="fstat-no" title="function not covered" ></span>co</span>mpile(){<span class="cstat-no" title="statement not covered" >0===this.regexes.length&amp;&amp;(this.exec=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null)</span>;v</span>ar e=<span class="cstat-no" title="statement not covered" >this.regexes.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e[1])</span>;<span class="cstat-no" title="statement not covered" ></span>this.matcherRe=s(g(e,{joinWith:"|"}),!0),this.lastIndex=0}<span class="fstat-no" title="function not covered" ></span>ex</span>ec(e){<span class="cstat-no" title="statement not covered" >this.matcherRe.lastIndex=this.lastIndex;c</span>onst n=<span class="cstat-no" title="statement not covered" >this.matcherRe.exec(e);<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >n.findIndex(<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >0&lt;n&amp;&amp;void 0!==e)</span>,</span>t=<span class="cstat-no" title="statement not covered" >this.matchIndexes[e];<span class="cstat-no" title="statement not covered" ></span>return n.splice(0,e),Object.assign(n,t)}</span>}class o{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.rules=[],this.multiRegexes=[],this.count=0,this.lastIndex=0,this.regexIndex=0}<span class="fstat-no" title="function not covered" ></span>ge</span>tMatcher(e){<span class="cstat-no" title="statement not covered" >if(this.multiRegexes[e])<span class="cstat-no" title="statement not covered" >return this.multiRegexes[e];c</span></span>onst t=<span class="cstat-no" title="statement not covered" >new n;<span class="cstat-no" title="statement not covered" ></span>return this.rules.slice(e).forEach(<span class="fstat-no" title="function not covered" >([</span>e,n])=&gt;<span class="cstat-no" title="statement not covered" >t.addRule(e,n))</span>,t.compile(),this.multiRegexes[e]=t}<span class="fstat-no" title="function not covered" ></span>re</span>sumingScanAtSamePosition(){<span class="cstat-no" title="statement not covered" >return 0!==this.regexIndex}<span class="fstat-no" title="function not covered" ></span>co</span>nsiderAll(){<span class="cstat-no" title="statement not covered" >this.regexIndex=0}<span class="fstat-no" title="function not covered" ></span>ad</span>dRule(e,n){<span class="cstat-no" title="statement not covered" >this.rules.push([e,n]),"begin"===n.type&amp;&amp;this.count++}<span class="fstat-no" title="function not covered" ></span>ex</span>ec(e){const n=<span class="cstat-no" title="statement not covered" >this.getMatcher(this.regexIndex);<span class="cstat-no" title="statement not covered" ></span>n.lastIndex=this.lastIndex;l</span>et t=<span class="cstat-no" title="statement not covered" >n.exec(e);<span class="cstat-no" title="statement not covered" ></span>if(this.resumingScanAtSamePosition()&amp;&amp;(!t||t.index!==this.lastIndex)){const a=<span class="cstat-no" title="statement not covered" >this.getMatcher(0);<span class="cstat-no" title="statement not covered" ></span>a.lastIndex=this.lastIndex+1,t=a.exec(e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t&amp;&amp;(this.regexIndex+=t.position+1,this.regexIndex===this.count&amp;&amp;this.considerAll()),t}</span>}<span class="cstat-no" title="statement not covered" >if(r.compilerExtensions||(r.compilerExtensions=[]),r.contains&amp;&amp;r.contains.includes("self"))<span class="cstat-no" title="statement not covered" >throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.classNameAliases=l(r.classNameAliases||{}),function <span class="fstat-no" title="function not covered" >n(</span>t,a){const i=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(!t.isCompiled){<span class="cstat-no" title="statement not covered" >[P,Z,q,K].forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e(t,a))</span>,r.compilerExtensions.forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e(t,a))</span>,t.__beforeBegin=null,[U,H,G].forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e(t,a))</span>,t.isCompiled=!0;l</span>et e=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>"object"==typeof t.keywords&amp;&amp;t.keywords.$pattern&amp;&amp;(t.keywords=Object.assign({},t.keywords),e=t.keywords.$pattern,delete t.keywords.$pattern),e=e||/\w+/,t.keywords&amp;&amp;(t.keywords=_(t.keywords,r.case_insensitive)),i.keywordPatternRe=s(e,!0),a&amp;&amp;(t.begin||(t.begin=/\B|\b/),i.beginRe=s(t.begin),t.end||t.endsWithParent||(t.end=/\B|\b/),t.end&amp;&amp;(i.endRe=s(t.end)),i.terminatorEnd=c(t.end)||"",t.endsWithParent&amp;&amp;a.terminatorEnd&amp;&amp;(i.terminatorEnd+=(t.end?"|":"")+a.terminatorEnd)),t.illegal&amp;&amp;(i.illegalRe=s(t.illegal)),t.contains||(t.contains=[]),t.contains=[].concat(...t.contains.map(<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >"self"===e?t:e;<span class="cstat-no" title="statement not covered" ></span>return n.variants&amp;&amp;!n.cachedVariants&amp;&amp;(n.cachedVariants=n.variants.map(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return l(n,{variants:null},e)}</span>)),n.cachedVariants||(function <span class="fstat-no" title="function not covered" >e(</span>n){<span class="cstat-no" title="statement not covered" >return!!n&amp;&amp;(n.endsWithParent||e(n.starts))}</span>(n)?l(n,{starts:n.starts?l(n.starts):null}):Object.isFrozen(n)?l(n):n)}</span>)),t.contains.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >n(e,i)}</span>),t.starts&amp;&amp;n(t.starts,a),i.matcher=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const n=<span class="cstat-no" title="statement not covered" >new o;<span class="cstat-no" title="statement not covered" ></span>return e.contains.forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >n.addRule(e.begin,{rule:e,type:"begin"}))</span>,e.terminatorEnd&amp;&amp;n.addRule(e.terminatorEnd,{type:"end"}),e.illegal&amp;&amp;n.addRule(e.illegal,{type:"illegal"}),n}</span>(i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>(r)}</span>const C=<span class="cstat-no" title="statement not covered" >n,</span>F=<span class="cstat-no" title="statement not covered" >l,</span>J=<span class="cstat-no" title="statement not covered" >Symbol("nomatch");<span class="cstat-no" title="statement not covered" ></span>m=<span class="fstat-no" title="function not covered" >fu</span>nction(a){const O=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>r=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>i=<span class="cstat-no" title="statement not covered" >[];</span>let S=<span class="cstat-no" title="statement not covered" >!0;</span>const M=<span class="cstat-no" title="statement not covered" >"Could not find the language '{}', did you forget to load/include a language module?",</span>s=<span class="cstat-no" title="statement not covered" >{disableAutodetect:!0,name:"Plain text",contains:[]};</span>let R=<span class="cstat-no" title="statement not covered" >{ignoreUnescapedHTML:!1,noHighlightRe:/^(no-?highlight)$/i,languageDetectRe:/\blang(?:uage)?-([\w-]+)\b/i,classPrefix:"hljs-",cssSelector:"pre code",languages:null,__emitter:L};</span>function <span class="fstat-no" title="function not covered" >o(</span>e){<span class="cstat-no" title="statement not covered" >return R.noHighlightRe.test(e)}</span>function <span class="fstat-no" title="function not covered" >l(</span>e,n,t,a){let i=<span class="cstat-no" title="statement not covered" >"",</span>r=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>"object"==typeof n?(i=e,t=n.ignoreIllegals,r=n.language,a=void 0):(A("10.7.0","highlight(lang, code, ...args) has been deprecated."),A("10.7.0","Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277"),r=e,i=n),void 0===t&amp;&amp;(t=!0);<span class="cstat-no" title="statement not covered" >e</span>={code:i,language:r};<span class="cstat-no" title="statement not covered" >u</span>("before:highlight",e);c</span>onst s=<span class="cstat-no" title="statement not covered" >e.result||B(e.language,e.code,t,a);<span class="cstat-no" title="statement not covered" ></span>return s.code=e.code,u("after:highlight",s),s}</span>function <span class="fstat-no" title="function not covered" >B(</span>r,s,o,e){const l=<span class="cstat-no" title="statement not covered" >Object.create(null);</span>function <span class="fstat-no" title="function not covered" >c(</span>){<span class="cstat-no" title="statement not covered" >if(m.keywords){let e=<span class="cstat-no" title="statement not covered" >0,</span>n=(<span class="cstat-no" title="statement not covered" >m.keywordPatternRe.lastIndex=0,m.keywordPatternRe.exec(v))</span>,t=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(;n;){<span class="cstat-no" title="statement not covered" >t+=v.substring(e,n.index);v</span>ar a=<span class="cstat-no" title="statement not covered" >p.case_insensitive?n[0].toLowerCase():n[0],</span>i=<span class="cstat-no" title="statement not covered" >m.keywords[a];<span class="cstat-no" title="statement not covered" ></span>if(i){const[r,s]=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>E.addText(t),t="",l[a]=(l[a]||0)+1,l[a]&lt;=7&amp;&amp;(w+=s),r.startsWith("_")?t+=n[0]:(i=p.classNameAliases[r]||r,E.addKeyword(n[0],i))}</span>else <span class="cstat-no" title="statement not covered" >t+=n[0];<span class="cstat-no" title="statement not covered" >e</span></span>=m.keywordPatternRe.lastIndex,n=m.keywordPatternRe.exec(v)}<span class="cstat-no" title="statement not covered" ></span>t</span>+=v.substr(e),E.addText(t)}</span>else <span class="cstat-no" title="statement not covered" >E.addText(v)}</span></span>function <span class="fstat-no" title="function not covered" >d(</span>){<span class="cstat-no" title="statement not covered" >(null!=m.subLanguage?<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(""!==v){let e=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof m.subLanguage){<span class="cstat-no" title="statement not covered" >if(!O[m.subLanguage])<span class="cstat-no" title="statement not covered" >return E.addText(v);<span class="cstat-no" title="statement not covered" >e</span></span>=B(m.subLanguage,v,!0,f[m.subLanguage]),f[m.subLanguage]=e._top}</span>else <span class="cstat-no" title="statement not covered" >e=T(v,m.subLanguage.length?m.subLanguage:null);<span class="cstat-no" title="statement not covered" >0</span></span>&lt;m.relevance&amp;&amp;(w+=e.relevance),E.addSublanguage(e._emitter,e.language)}</span>}</span>:c)(),v=""}</span>function <span class="fstat-no" title="function not covered" >i(</span>e,n){let t=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>for(;void 0!==n[t];){var a,i;<span class="cstat-no" title="statement not covered" >e._emit[t]?(a=p.classNameAliases[e[t]]||e[t],i=n[t],a?E.addKeyword(i,a):(v=i,c(),v=""),t++):t++}</span>}</span>function <span class="fstat-no" title="function not covered" >u(</span>e,n){<span class="cstat-no" title="statement not covered" >e.scope&amp;&amp;"string"==typeof e.scope&amp;&amp;E.openNode(p.classNameAliases[e.scope]||e.scope),e.beginScope&amp;&amp;(e.beginScope._wrap?(E.addKeyword(v,p.classNameAliases[e.beginScope._wrap]||e.beginScope._wrap),v=""):e.beginScope._multi&amp;&amp;(i(e.beginScope,n),v="")),m=Object.create(e,{parent:{value:m}})}</span>function <span class="fstat-no" title="function not covered" >g(</span>e){var n,t=<span class="cstat-no" title="statement not covered" >e[0],</span>a=<span class="cstat-no" title="statement not covered" >e.rule,</span>i=<span class="cstat-no" title="statement not covered" >new D(a);<span class="cstat-no" title="statement not covered" ></span>for(const r of[a.__beforeBegin,a["on:begin"]])<span class="cstat-no" title="statement not covered" >if(r&amp;&amp;(r(e,i),i.isMatchIgnored))<span class="cstat-no" title="statement not covered" >return n=t,0===m.matcher.regexIndex?(v+=n[0],1):(N=!0,0);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn a.skip?v+=t:(a.excludeBegin&amp;&amp;(v+=t),d(),a.returnBegin||a.excludeBegin||(v=t)),u(a,e),a.returnBegin?0:t.length}</span>function <span class="fstat-no" title="function not covered" >b(</span>e){var n=<span class="cstat-no" title="statement not covered" >e[0],</span>t=<span class="cstat-no" title="statement not covered" >s.substr(e.index),</span>a=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >e(</span>n,t,a){<span class="cstat-no" title="statement not covered" >r=n.endRe,s=a;l</span>et i=<span class="cstat-no" title="statement not covered" >(r=r&amp;&amp;r.exec(s))&amp;&amp;0===r.index;</span>var r,s;<span class="cstat-no" title="statement not covered" >if(i&amp;&amp;(n["on:end"]&amp;&amp;(s=new D(n),n["on:end"](t,s),s.isMatchIgnored&amp;&amp;(i=!1)),i)){<span class="cstat-no" title="statement not covered" >for(;n.endsParent&amp;&amp;n.parent;)<span class="cstat-no" title="statement not covered" >n=n.parent;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n.endsWithParent)<span class="cstat-no" title="statement not covered" >return e(n.parent,t,a)}</span></span>(m,e,t);<span class="cstat-no" title="statement not covered" ></span>if(!a)<span class="cstat-no" title="statement not covered" >return J;<span class="cstat-no" title="statement not covered" >t</span></span>=m;<span class="cstat-no" title="statement not covered" >f</span>or(m.endScope&amp;&amp;m.endScope._wrap?(d(),E.addKeyword(n,m.endScope._wrap)):m.endScope&amp;&amp;m.endScope._multi?(d(),i(m.endScope,e)):t.skip?v+=n:(t.returnEnd||t.excludeEnd||(v+=n),d(),t.excludeEnd&amp;&amp;(v=n));m.scope&amp;&amp;!m.isMultiClass&amp;&amp;E.closeNode(),m.skip||m.subLanguage||(w+=m.relevance),(m=m.parent)!==a.parent;);<span class="cstat-no" title="statement not covered" >r</span>eturn a.starts&amp;&amp;u(a.starts,e),t.returnEnd?0:n.length}</span>let h=<span class="cstat-no" title="statement not covered" >{};</span>function <span class="fstat-no" title="function not covered" >n(</span>e,n){var t=<span class="cstat-no" title="statement not covered" >n&amp;&amp;n[0];<span class="cstat-no" title="statement not covered" ></span>if(v+=e,null==t)<span class="cstat-no" title="statement not covered" >return d(),0;<span class="cstat-no" title="statement not covered" >i</span></span>f("begin"===h.type&amp;&amp;"end"===n.type&amp;&amp;h.index===n.index&amp;&amp;""===t){<span class="cstat-no" title="statement not covered" >if(v+=s.slice(n.index,n.index+1),S)<span class="cstat-no" title="statement not covered" >return 1;{</span></span>const a=<span class="cstat-no" title="statement not covered" >new Error(`0 width match regex (${r})`);<span class="cstat-no" title="statement not covered" ></span>throw a.languageName=r,a.badRule=h.rule,a}</span>}<span class="cstat-no" title="statement not covered" >i</span>f("begin"===(h=n).type)<span class="cstat-no" title="statement not covered" >return g(n);<span class="cstat-no" title="statement not covered" >i</span></span>f("illegal"===n.type&amp;&amp;!o){const i=<span class="cstat-no" title="statement not covered" >new Error('Illegal lexeme "'+t+'" for mode "'+(m.scope||"&lt;unnamed&gt;")+'"');<span class="cstat-no" title="statement not covered" ></span>throw i.mode=m,i}<span class="cstat-no" title="statement not covered" ></span>i</span>f("end"===n.type){<span class="cstat-no" title="statement not covered" >e=b(n);<span class="cstat-no" title="statement not covered" >i</span>f(e!==J)<span class="cstat-no" title="statement not covered" >return e}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f("illegal"===n.type&amp;&amp;""===t)<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span></span>f(1e5&lt;_&amp;&amp;_&gt;3*n.index)<span class="cstat-no" title="statement not covered" >throw new Error("potential infinite loop, way more iterations than matches");<span class="cstat-no" title="statement not covered" >r</span></span>eturn v+=t,t.length}</span>const p=<span class="cstat-no" title="statement not covered" >I(r);<span class="cstat-no" title="statement not covered" ></span>if(!p)<span class="cstat-no" title="statement not covered" >throw j(M.replace("{}",r)),new Error('Unknown language: "'+r+'"');v</span></span>ar t=<span class="cstat-no" title="statement not covered" >Q(p);</span>let a=<span class="cstat-no" title="statement not covered" >"",</span>m=<span class="cstat-no" title="statement not covered" >e||t;</span>const f=<span class="cstat-no" title="statement not covered" >{},</span>E=<span class="cstat-no" title="statement not covered" >new R.__emitter(R);</span>{const k=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >m;</span>e!==p;e=e.parent)<span class="cstat-no" title="statement not covered" >e.scope&amp;&amp;k.unshift(e.scope);<span class="cstat-no" title="statement not covered" >k</span></span>.forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >E.openNode(e))</span>}</span>let v=<span class="cstat-no" title="statement not covered" >"",</span>w=<span class="cstat-no" title="statement not covered" >0,</span>y=<span class="cstat-no" title="statement not covered" >0,</span>_=<span class="cstat-no" title="statement not covered" >0,</span>N=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >for(m.matcher.considerAll();;){<span class="cstat-no" title="statement not covered" >_++,N?N=!1:m.matcher.considerAll(),m.matcher.lastIndex=y;v</span>ar x=<span class="cstat-no" title="statement not covered" >m.matcher.exec(s);<span class="cstat-no" title="statement not covered" ></span>if(!x)<span class="cstat-no" title="statement not covered" >break;v</span></span>ar A=<span class="cstat-no" title="statement not covered" >n(s.substring(y,x.index),x);<span class="cstat-no" title="statement not covered" ></span>y=x.index+A}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n(s.substr(y)),E.closeAllNodes(),E.finalize(),a=E.toHTML(),{language:r,value:a,relevance:w,illegal:!1,_emitter:E,_top:m}}</span>catch(e){<span class="cstat-no" title="statement not covered" >if(e.message&amp;&amp;e.message.includes("Illegal"))<span class="cstat-no" title="statement not covered" >return{language:r,value:C(s),illegal:!0,relevance:0,_illegalBy:{message:e.message,index:y,context:s.slice(y-100,y+100),mode:e.mode,resultSoFar:a},_emitter:E};<span class="cstat-no" title="statement not covered" >i</span></span>f(S)<span class="cstat-no" title="statement not covered" >return{language:r,value:C(s),illegal:!1,relevance:0,errorRaised:e,_emitter:E,_top:m};<span class="cstat-no" title="statement not covered" >t</span></span>hrow e}</span>}</span>function <span class="fstat-no" title="function not covered" >T(</span>n,e){<span class="cstat-no" title="statement not covered" >e=e||R.languages||Object.keys(O);v</span>ar t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){const n=<span class="cstat-no" title="statement not covered" >{value:C(e),illegal:!1,relevance:0,_top:s,_emitter:new R.__emitter(R)};<span class="cstat-no" title="statement not covered" ></span>return n._emitter.addText(e),n}</span>(n);</span>const a=<span class="cstat-no" title="statement not covered" >e.filter(I).filter(d).map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >B(e,n,!1))</span>;<span class="cstat-no" title="statement not covered" ></span>a.unshift(t);v</span>ar[e,t]=<span class="cstat-no" title="statement not covered" >a.sort(<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >if(e.relevance!==n.relevance)<span class="cstat-no" title="statement not covered" >return n.relevance-e.relevance;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.language&amp;&amp;n.language){<span class="cstat-no" title="statement not covered" >if(I(e.language).supersetOf===n.language)<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span></span>f(I(n.language).supersetOf===e.language)<span class="cstat-no" title="statement not covered" >return-1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn 0}</span>);</span>const i=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return i.secondBest=t,i}</span>function <span class="fstat-no" title="function not covered" >n(</span>e){var n,t,a,i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){let n=<span class="cstat-no" title="statement not covered" >e.className+" ";<span class="cstat-no" title="statement not covered" ></span>n+=e.parentNode?e.parentNode.className:"";v</span>ar t,a=<span class="cstat-no" title="statement not covered" >R.languageDetectRe.exec(n);<span class="cstat-no" title="statement not covered" ></span>return a?((t=I(a[1]))||(x(M.replace("{}",a[1])),x("Falling back to no-highlight mode for this block.",e)),t?a[1]:"no-highlight"):n.split(/\s+/).find(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >o(e)||I(e))</span>}</span>(e);<span class="cstat-no" title="statement not covered" ></span>o(i)||(u("before:highlightElement",{el:e,language:i}),!R.ignoreUnescapedHTML&amp;&amp;0&lt;e.children.length&amp;&amp;(console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."),console.warn("https://github.com/highlightjs/highlight.js/issues/2886"),console.warn(e)),t=e.textContent,u("after:highlightElement",{el:e,result:n=i?l(t,{language:i,ignoreIllegals:!0}):T(t),text:t}),e.innerHTML=n.value,t=e,i=i,a=n.language,i=i&amp;&amp;r[i]||a,t.classList.add("hljs"),t.classList.add("language-"+i),e.result={language:n.language,re:n.relevance,relevance:n.relevance},n.secondBest&amp;&amp;(e.secondBest={language:n.secondBest.language,relevance:n.secondBest.relevance}))}</span>let t=<span class="cstat-no" title="statement not covered" >!1;</span>function <span class="fstat-no" title="function not covered" >e(</span>){<span class="cstat-no" title="statement not covered" >if("loading"===document.readyState)<span class="cstat-no" title="statement not covered" >t=!0;e</span>lse{const e=<span class="cstat-no" title="statement not covered" >document.querySelectorAll(R.cssSelector);<span class="cstat-no" title="statement not covered" ></span>e.forEach(n)}</span>}</span>function <span class="fstat-no" title="function not covered" >I(</span>e){<span class="cstat-no" title="statement not covered" >return e=(e||"").toLowerCase(),O[e]||O[r[e]]}</span>function <span class="fstat-no" title="function not covered" >c(</span>e,{languageName:n}){<span class="cstat-no" title="statement not covered" >(e="string"==typeof e?[e]:e).forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >r[e.toLowerCase()]=n}</span>)}</span>function <span class="fstat-no" title="function not covered" >d(</span>e){<span class="cstat-no" title="statement not covered" >e=I(e);<span class="cstat-no" title="statement not covered" >r</span>eturn e&amp;&amp;!e.disableAutodetect}</span>function <span class="fstat-no" title="function not covered" >u(</span>e,n){const t=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>i.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e[t]&amp;&amp;e[t](n)}</span>)}<span class="cstat-no" title="statement not covered" ></span>"undefined"!=typeof window&amp;&amp;window.addEventListener&amp;&amp;window.addEventListener("DOMContentLoaded",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t&amp;&amp;e()}</span>,!1),Object.assign(a,{highlight:l,highlightAuto:T,highlightAll:e,highlightElement:n,highlightBlock:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return A("10.7.0","highlightBlock will be removed entirely in v12.0"),A("10.7.0","Please use highlightElement now."),n(e)}</span>,configure:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >R=F(R,e)}</span>,initHighlighting:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e(),A("10.6.0","initHighlighting() deprecated.  Use highlightAll() now.")}</span>,initHighlightingOnLoad:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e(),A("10.6.0","initHighlightingOnLoad() deprecated.  Use highlightAll() now.")}</span>,registerLanguage:<span class="fstat-no" title="function not covered" >fu</span>nction(n,e){let t=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >t=e(a)}</span>catch(e){<span class="cstat-no" title="statement not covered" >if(j("Language definition for '{}' could not be registered.".replace("{}",n)),!S)<span class="cstat-no" title="statement not covered" >throw e;<span class="cstat-no" title="statement not covered" >j</span></span>(e),t=s}<span class="cstat-no" title="statement not covered" ></span>t</span>.name||(t.name=n),(O[n]=t).rawDefinition=e.bind(null,a),t.aliases&amp;&amp;c(t.aliases,{languageName:n})}</span>,unregisterLanguage:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >delete O[e];<span class="cstat-no" title="statement not covered" >f</span>or(const n of Object.keys(r))<span class="cstat-no" title="statement not covered" >r[n]===e&amp;&amp;delete r[n]}</span></span>,listLanguages:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Object.keys(O)}</span>,getLanguage:I,registerAliases:c,autoDetection:d,inherit:F,addPlugin:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n;<span class="cstat-no" title="statement not covered" >(n=e)["before:highlightBlock"]&amp;&amp;!n["before:highlightElement"]&amp;&amp;(n["before:highlightElement"]=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >n["before:highlightBlock"](Object.assign({block:e.el},e))}</span>),n["after:highlightBlock"]&amp;&amp;!n["after:highlightElement"]&amp;&amp;(n["after:highlightElement"]=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >n["after:highlightBlock"](Object.assign({block:e.el},e))}</span>),i.push(e)}</span>}),a.debugMode=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >S=!1}</span>,a.safeMode=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >S=!0}</span>,a.versionString="11.0.0-beta1";<span class="cstat-no" title="statement not covered" >f</span>or(const g in y)<span class="cstat-no" title="statement not covered" >"object"==typeof y[g]&amp;&amp;z(y[g]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn Object.assign(a,y),a}</span>({});c</span>onst V=<span class="cstat-no" title="statement not covered" >["a","abbr","address","article","aside","audio","b","blockquote","body","button","canvas","caption","cite","code","dd","del","details","dfn","div","dl","dt","em","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","html","i","iframe","img","input","ins","kbd","label","legend","li","main","mark","menu","nav","object","ol","p","q","quote","samp","section","span","strong","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","tr","ul","var","video"],</span>Y=<span class="cstat-no" title="statement not covered" >["any-hover","any-pointer","aspect-ratio","color","color-gamut","color-index","device-aspect-ratio","device-height","device-width","display-mode","forced-colors","grid","height","hover","inverted-colors","monochrome","orientation","overflow-block","overflow-inline","pointer","prefers-color-scheme","prefers-contrast","prefers-reduced-motion","prefers-reduced-transparency","resolution","scan","scripting","update","width","min-width","max-width","min-height","max-height"],</span>ee=<span class="cstat-no" title="statement not covered" >["active","any-link","blank","checked","current","default","defined","dir","disabled","drop","empty","enabled","first","first-child","first-of-type","fullscreen","future","focus","focus-visible","focus-within","has","host","host-context","hover","indeterminate","in-range","invalid","is","lang","last-child","last-of-type","left","link","local-link","not","nth-child","nth-col","nth-last-child","nth-last-col","nth-last-of-type","nth-of-type","only-child","only-of-type","optional","out-of-range","past","placeholder-shown","read-only","read-write","required","right","root","scope","target","target-within","user-invalid","valid","visited","where"],</span>ne=<span class="cstat-no" title="statement not covered" >["after","backdrop","before","cue","cue-region","first-letter","first-line","grammar-error","marker","part","placeholder","selection","slotted","spelling-error"],</span>te=<span class="cstat-no" title="statement not covered" >["align-content","align-items","align-self","animation","animation-delay","animation-direction","animation-duration","animation-fill-mode","animation-iteration-count","animation-name","animation-play-state","animation-timing-function","auto","backface-visibility","background","background-attachment","background-clip","background-color","background-image","background-origin","background-position","background-repeat","background-size","border","border-bottom","border-bottom-color","border-bottom-left-radius","border-bottom-right-radius","border-bottom-style","border-bottom-width","border-collapse","border-color","border-image","border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width","border-left","border-left-color","border-left-style","border-left-width","border-radius","border-right","border-right-color","border-right-style","border-right-width","border-spacing","border-style","border-top","border-top-color","border-top-left-radius","border-top-right-radius","border-top-style","border-top-width","border-width","bottom","box-decoration-break","box-shadow","box-sizing","break-after","break-before","break-inside","caption-side","clear","clip","clip-path","color","column-count","column-fill","column-gap","column-rule","column-rule-color","column-rule-style","column-rule-width","column-span","column-width","columns","content","counter-increment","counter-reset","cursor","direction","display","empty-cells","filter","flex","flex-basis","flex-direction","flex-flow","flex-grow","flex-shrink","flex-wrap","float","font","font-display","font-family","font-feature-settings","font-kerning","font-language-override","font-size","font-size-adjust","font-smoothing","font-stretch","font-style","font-variant","font-variant-ligatures","font-variation-settings","font-weight","height","hyphens","icon","image-orientation","image-rendering","image-resolution","ime-mode","inherit","initial","justify-content","left","letter-spacing","line-height","list-style","list-style-image","list-style-position","list-style-type","margin","margin-bottom","margin-left","margin-right","margin-top","marks","mask","max-height","max-width","min-height","min-width","nav-down","nav-index","nav-left","nav-right","nav-up","none","normal","object-fit","object-position","opacity","order","orphans","outline","outline-color","outline-offset","outline-style","outline-width","overflow","overflow-wrap","overflow-x","overflow-y","padding","padding-bottom","padding-left","padding-right","padding-top","page-break-after","page-break-before","page-break-inside","perspective","perspective-origin","pointer-events","position","quotes","resize","right","src","tab-size","table-layout","text-align","text-align-last","text-decoration","text-decoration-color","text-decoration-line","text-decoration-style","text-indent","text-overflow","text-rendering","text-shadow","text-transform","text-underline-position","top","transform","transform-origin","transform-style","transition","transition-delay","transition-duration","transition-property","transition-timing-function","unicode-bidi","vertical-align","visibility","white-space","widows","width","word-break","word-spacing","word-wrap","z-index"].reverse();<span class="cstat-no" title="statement not covered" ></span>ee.concat(ne);c</span>onst R=<span class="cstat-no" title="statement not covered" >"[A-Za-z$_][0-9A-Za-z$_]*",</span>ae=<span class="cstat-no" title="statement not covered" >["as","in","of","if","for","while","finally","var","new","function","do","return","void","else","break","catch","instanceof","with","throw","case","default","try","switch","continue","typeof","delete","let","yield","const","class","debugger","async","await","static","import","from","export","extends"],</span>ie=<span class="cstat-no" title="statement not covered" >["true","false","null","undefined","NaN","Infinity"],</span>re=<span class="cstat-no" title="statement not covered" >["Intl","DataView","Number","Math","Date","String","RegExp","Object","Function","Boolean","Error","Symbol","Set","Map","WeakSet","WeakMap","Proxy","Reflect","JSON","Promise","Float64Array","Int16Array","Int32Array","Int8Array","Uint16Array","Uint32Array","Float32Array","Array","Uint8Array","Uint8ClampedArray","ArrayBuffer","BigInt64Array","BigUint64Array","BigInt"],</span>se=<span class="cstat-no" title="statement not covered" >["EvalError","InternalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError"],</span>oe=<span class="cstat-no" title="statement not covered" >["setInterval","setTimeout","clearInterval","clearTimeout","require","exports","eval","isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","unescape"],</span>le=<span class="cstat-no" title="statement not covered" >["arguments","this","super","console","window","document","localStorage","module","global"],</span>ce=<span class="cstat-no" title="statement not covered" >[].concat(oe,re,se);</span>function <span class="fstat-no" title="function not covered" >de(</span>e){var n=<span class="cstat-no" title="statement not covered" >R;</span>const t=<span class="cstat-no" title="statement not covered" >"&lt;&gt;",</span>a=<span class="cstat-no" title="statement not covered" >"&lt;/&gt;",</span>i=<span class="cstat-no" title="statement not covered" >/&lt;[A-Za-z0-9\\._:-]+/,</span>r=<span class="cstat-no" title="statement not covered" >/\/[A-Za-z0-9\\._:-]+&gt;|\/&gt;/,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{var t=<span class="cstat-no" title="statement not covered" >e[0].length+e.index,</span>a=<span class="cstat-no" title="statement not covered" >e.input[t];<span class="cstat-no" title="statement not covered" ></span>"&lt;"===a?n.ignoreMatch():"&gt;"===a&amp;&amp;([a,e]=[e,{after:t}["after"]],t="&lt;/"+a[0].slice(1),-1===a.input.indexOf(t,e)&amp;&amp;n.ignoreMatch())}</span>;</span>var o=<span class="cstat-no" title="statement not covered" >{$pattern:R,keyword:ae,literal:ie,built_in:ce,"variable.language":le},</span>l=<span class="cstat-no" title="statement not covered" >"[0-9](_?[0-9])*",</span>c=<span class="cstat-no" title="statement not covered" >`\\.(${l})`,</span>d=<span class="cstat-no" title="statement not covered" >"0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*",</span>l=<span class="cstat-no" title="statement not covered" >{className:"number",variants:[{begin:`(\\b(${d})((${c})|\\.)?|(${c}))`+`[eE][+-]?(${l})\\b`},{begin:`\\b(${d})\\b((${c})\\b|\\.)?|(${c})\\b`},{begin:"\\b(0|[1-9](_?[0-9])*)n\\b"},{begin:"\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"},{begin:"\\b0[bB][0-1](_?[0-1])*n?\\b"},{begin:"\\b0[oO][0-7](_?[0-7])*n?\\b"},{begin:"\\b0[0-7]+n?\\b"}],relevance:0};</span>const u=<span class="cstat-no" title="statement not covered" >{className:"subst",begin:"\\$\\{",end:"\\}",keywords:o,contains:[]};</span>var d=<span class="cstat-no" title="statement not covered" >{begin:"html`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,u],subLanguage:"xml"}},</span>c=<span class="cstat-no" title="statement not covered" >{begin:"css`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,u],subLanguage:"css"}},</span>g=<span class="cstat-no" title="statement not covered" >{className:"string",begin:"`",end:"`",contains:[e.BACKSLASH_ESCAPE,u]},</span>b=<span class="cstat-no" title="statement not covered" >{className:"comment",variants:[e.COMMENT(/\/\*\*(?!\/)/,"\\*/",{relevance:0,contains:[{begin:"(?=@[A-Za-z]+)",relevance:0,contains:[{className:"doctag",begin:"@[A-Za-z]+"},{className:"type",begin:"\\{",end:"\\}",excludeEnd:!0,excludeBegin:!0,relevance:0},{className:"variable",begin:n+"(?=\\s*(-)|$)",endsParent:!0,relevance:0},{begin:/(?=[^\n])\s/,relevance:0}]}]}),e.C_BLOCK_COMMENT_MODE,e.C_LINE_COMMENT_MODE]};</span>const h=<span class="cstat-no" title="statement not covered" >[e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,d,c,g,l,e.REGEXP_MODE],</span>p=(<span class="cstat-no" title="statement not covered" >u.contains=h.concat({begin:/\{/,end:/\}/,keywords:o,contains:["self"].concat(h)}),[].concat(b,u.contains))</span>;var m=<span class="cstat-no" title="statement not covered" >p.concat([{begin:/\(/,end:/\)/,keywords:o,contains:["self"].concat(p)}]),</span>f=<span class="cstat-no" title="statement not covered" >{className:"params",begin:/\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,keywords:o,contains:m},</span>E=<span class="cstat-no" title="statement not covered" >{variants:[{match:[/class/,/\s+/,n],scope:{1:"keyword",3:"title.class"}},{match:[/extends/,/\s+/,O(n,"(",O(/\./,n),")*")],scope:{1:"keyword",3:"title.class.inherited"}}]},</span>v=<span class="cstat-no" title="statement not covered" >{relevance:0,match:/\b[A-Z][a-z]+([A-Z][a-z]+)*/,className:"title.class",keywords:{_:[...re,...se]}},</span>w=<span class="cstat-no" title="statement not covered" >{variants:[{match:[/function/,/\s+/,n,/(?=\s*\()/]},{match:[/function/,/\s*(?=\()/]}],className:{1:"keyword",3:"title.function"},label:"func.def",contains:[f],illegal:/%/};</span>var y=<span class="cstat-no" title="statement not covered" >{match:O(/\b/,O("(?!",[...oe,"super"].join("|"),")"),n,k(/\(/)),className:"title.function",relevance:0},</span>_=<span class="cstat-no" title="statement not covered" >{begin:O(/\./,k(O(n,/(?![0-9A-Za-z$_(])/))),end:n,excludeBegin:!0,keywords:"prototype",className:"property",relevance:0},</span>N=<span class="cstat-no" title="statement not covered" >{match:[/get|set/,/\s+/,n,/(?=\()/],className:{1:"keyword",3:"title.function"},contains:[{begin:/\(\)/},f]},</span>x=<span class="cstat-no" title="statement not covered" >"(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|"+e.UNDERSCORE_IDENT_RE+")\\s*=&gt;",</span>A=<span class="cstat-no" title="statement not covered" >{match:[/const|var|let/,/\s+/,n,/\s*/,/=\s*/,k(x)],className:{1:"keyword",3:"title.function"},contains:[f]};<span class="cstat-no" title="statement not covered" ></span>return{name:"Javascript",aliases:["js","jsx","mjs","cjs"],keywords:o,exports:{PARAMS_CONTAINS:m},illegal:/#(?![$_A-z])/,contains:[e.SHEBANG({label:"shebang",binary:"node",relevance:5}),{label:"use_strict",className:"meta",relevance:10,begin:/^\s*['"]use (strict|asm)['"]/},e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,d,c,g,b,l,v,{className:"attr",begin:n+k(":"),relevance:0},A,{begin:"("+e.RE_STARTERS_RE+"|\\b(case|return|throw)\\b)\\s*",keywords:"return throw case",relevance:0,contains:[b,e.REGEXP_MODE,{className:"function",begin:x,returnBegin:!0,end:"\\s*=&gt;",contains:[{className:"params",variants:[{begin:e.UNDERSCORE_IDENT_RE,relevance:0},{className:null,begin:/\(\s*\)/,skip:!0},{begin:/\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,keywords:o,contains:m}]}]},{begin:/,/,relevance:0},{match:/\s+/,relevance:0},{variants:[{begin:t,end:a},{begin:i,"on:begin":s,end:r}],subLanguage:"xml",contains:[{begin:i,end:r,skip:!0,contains:["self"]}]}]},w,{beginKeywords:"while if switch catch for"},{begin:"\\b(?!function)"+e.UNDERSCORE_IDENT_RE+"\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",returnBegin:!0,label:"func.def",contains:[f,e.inherit(e.TITLE_MODE,{begin:n,className:"title.function"})]},{match:/\.\.\./,relevance:0},_,{match:"\\$"+n,relevance:0},{match:[/\bconstructor(?=\s*\()/],className:{1:"title.function"},contains:[f]},y,{relevance:0,match:/\b[A-Z][A-Z_]+\b/,className:"variable.constant"},E,N,{match:/\$[(.]/}]}}</span>function <span class="fstat-no" title="function not covered" >ue(</span>e){var n=<span class="cstat-no" title="statement not covered" >{beginKeywords:["true","false","null"].join(" ")};<span class="cstat-no" title="statement not covered" ></span>return{name:"JSON",contains:[{className:"attr",begin:/"(\\.|[^\\"\r\n])*"(?=\s*:)/,relevance:1.01},{match:/[{}[\],:]/,className:"punctuation",relevance:0},e.QUOTE_STRING_MODE,n,e.C_NUMBER_MODE,e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE],illegal:"\\S"}}</span>function <span class="fstat-no" title="function not covered" >ge(</span>e){var n=<span class="cstat-no" title="statement not covered" >{IMPORTANT:{scope:"meta",begin:"!important"},HEXCOLOR:{scope:"number",begin:"#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})"},ATTRIBUTE_SELECTOR_MODE:{scope:"selector-attr",begin:/\[/,end:/\]/,illegal:"$",contains:[e.APOS_STRING_MODE,e.QUOTE_STRING_MODE]},CSS_NUMBER_MODE:{scope:"number",begin:e.NUMBER_RE+"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",relevance:0}};</span>const t=<span class="cstat-no" title="statement not covered" >ne,</span>a=<span class="cstat-no" title="statement not covered" >ee;</span>var i=<span class="cstat-no" title="statement not covered" >"@[a-z-]+",</span>r=<span class="cstat-no" title="statement not covered" >{className:"variable",begin:"(\\$[a-zA-Z-][a-zA-Z0-9_-]*)\\b"};<span class="cstat-no" title="statement not covered" ></span>return{name:"SCSS",case_insensitive:!0,illegal:"[=/|']",contains:[e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE,{className:"selector-id",begin:"#[A-Za-z0-9_-]+",relevance:0},{className:"selector-class",begin:"\\.[A-Za-z0-9_-]+",relevance:0},n.ATTRIBUTE_SELECTOR_MODE,{className:"selector-tag",begin:"\\b("+V.join("|")+")\\b",relevance:0},{className:"selector-pseudo",begin:":("+a.join("|")+")"},{className:"selector-pseudo",begin:"::("+t.join("|")+")"},r,{begin:/\(/,end:/\)/,contains:[n.CSS_NUMBER_MODE]},{className:"attribute",begin:"\\b("+te.join("|")+")\\b"},{begin:"\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b"},{begin:":",end:";",contains:[r,n.HEXCOLOR,n.CSS_NUMBER_MODE,e.QUOTE_STRING_MODE,e.APOS_STRING_MODE,n.IMPORTANT]},{begin:"@(page|font-face)",keywords:{$pattern:i,keyword:"@page @font-face"}},{begin:"@",end:"[{;]",returnBegin:!0,keywords:{$pattern:/[a-z-]+/,keyword:"and or not only",attribute:Y.join(" ")},contains:[{begin:i,className:"keyword"},{begin:/[a-z-]+(?=:)/,className:"attribute"},r,e.QUOTE_STRING_MODE,e.APOS_STRING_MODE,n.HEXCOLOR,n.CSS_NUMBER_MODE]}]}}<span class="cstat-no" title="statement not covered" ></span>f=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >O(/\b/,e,/\w$/.test(e)?/\b/:/\B/),</span>["Protocol","Type"].map(f),["init","self"].map(f),E=d(/[/=\-+!*%&lt;&gt;&amp;|^~?]/,/[\u00A1-\u00A7]/,/[\u00A9\u00AB]/,/[\u00AC\u00AE]/,/[\u00B0\u00B1]/,/[\u00B6\u00BB\u00BF\u00D7\u00F7]/,/[\u2016-\u2017]/,/[\u2020-\u2027]/,/[\u2030-\u203E]/,/[\u2041-\u2053]/,/[\u2055-\u205E]/,/[\u2190-\u23FF]/,/[\u2500-\u2775]/,/[\u2794-\u2BFF]/,/[\u2E00-\u2E7F]/,/[\u3001-\u3003]/,/[\u3008-\u3020]/,/[\u3030]/),O(E,d(E,/[\u0300-\u036F]/,/[\u1DC0-\u1DFF]/,/[\u20D0-\u20FF]/,/[\uFE00-\uFE0F]/,/[\uFE20-\uFE2F]/),"*"),v=d(/[a-zA-Z_]/,/[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,/[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,/[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,/[\u1E00-\u1FFF]/,/[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,/[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,/[\u2C00-\u2DFF\u2E80-\u2FFF]/,/[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,/[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,/[\uFE47-\uFEFE\uFF00-\uFFFD]/),w=d(v,/\d/,/[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/),o=O(v,w,"*");<span class="cstat-no" title="statement not covered" >O</span>(/[A-Z]/,w,"*"),O(/convention\(/,d("swift","block","c"),/\)/),O(/objc\(/,o,/\)/);v</span>ar be=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,grmr_bash:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >{},</span>t=<span class="cstat-no" title="statement not covered" >{begin:/\$\{/,end:/\}/,contains:["self",{begin:/:-/,contains:[n]}]};<span class="cstat-no" title="statement not covered" ></span>Object.assign(n,{className:"variable",variants:[{begin:O(/\$[\w\d#@][\w\d_]*/,"(?![\\w\\d])(?![$])")},t]});c</span>onst a=<span class="cstat-no" title="statement not covered" >{className:"subst",begin:/\$\(/,end:/\)/,contains:[e.BACKSLASH_ESCAPE]};</span>var t=<span class="cstat-no" title="statement not covered" >{begin:/&lt;&lt;-?\s*(?=\w+)/,starts:{contains:[e.END_SAME_AS_BEGIN({begin:/(\w+)/,end:/(\w+)/,className:"string"})]}},</span>i=<span class="cstat-no" title="statement not covered" >{className:"string",begin:/"/,end:/"/,contains:[e.BACKSLASH_ESCAPE,n,a]},</span>r=(<span class="cstat-no" title="statement not covered" >a.contains.push(i),{begin:/\$\(\(/,end:/\)\)/,contains:[{begin:/\d+#[0-9a-f]+/,className:"number"},e.NUMBER_MODE,n]})</span>,s=<span class="cstat-no" title="statement not covered" >e.SHEBANG({binary:`(${["fish","bash","zsh","sh","csh","ksh","tcsh","dash","scsh"].join("|")})`,relevance:10}),</span>o=<span class="cstat-no" title="statement not covered" >{className:"function",begin:/\w[\w\d_]*\s*\(\s*\)\s*\{/,returnBegin:!0,contains:[e.inherit(e.TITLE_MODE,{begin:/\w[\w\d_]*/})],relevance:0};<span class="cstat-no" title="statement not covered" ></span>return{name:"Bash",aliases:["sh"],keywords:{$pattern:/\b[a-z._-]+\b/,keyword:["if","then","else","elif","fi","for","while","in","do","done","case","esac","function"],literal:["true","false"],built_in:"break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp"},contains:[s,e.SHEBANG(),o,r,e.HASH_COMMENT_MODE,t,i,{className:"",begin:/\\"/},{className:"string",begin:/'/,end:/'/},n]}}</span>,grmr_scss:ge,grmr_css:ge,grmr_javascript:de,grmr_json:ue,grmr_json5:ue,grmr_xml:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >O(/[A-Z_]/,O("(?:",/[A-Z0-9_.-]*:/,")?"),/[A-Z0-9_.-]*/),</span>t=<span class="cstat-no" title="statement not covered" >{className:"symbol",begin:/&amp;[a-z]+;|&amp;#[0-9]+;|&amp;#x[a-f0-9]+;/},</span>a=<span class="cstat-no" title="statement not covered" >{begin:/\s/,contains:[{className:"keyword",begin:/#?[a-z_][a-z1-9_-]+/,illegal:/\n/}]},</span>i=<span class="cstat-no" title="statement not covered" >e.inherit(a,{begin:/\(/,end:/\)/}),</span>r=<span class="cstat-no" title="statement not covered" >e.inherit(e.APOS_STRING_MODE,{className:"string"}),</span>s=<span class="cstat-no" title="statement not covered" >e.inherit(e.QUOTE_STRING_MODE,{className:"string"}),</span>o=<span class="cstat-no" title="statement not covered" >{endsWithParent:!0,illegal:/&lt;/,relevance:0,contains:[{className:"attr",begin:/[A-Za-z0-9._:-]+/,relevance:0},{begin:/=\s*/,relevance:0,contains:[{className:"string",endsParent:!0,variants:[{begin:/"/,end:/"/,contains:[t]},{begin:/'/,end:/'/,contains:[t]},{begin:/[^\s"'=&lt;&gt;`]+/}]}]}]};<span class="cstat-no" title="statement not covered" ></span>return{name:"HTML, XML",aliases:["html","xhtml","rss","atom","xjb","xsd","xsl","plist","wsf","svg"],case_insensitive:!0,contains:[{className:"meta",begin:/&lt;![a-z]/,end:/&gt;/,relevance:10,contains:[a,s,r,i,{begin:/\[/,end:/\]/,contains:[{className:"meta",begin:/&lt;![a-z]/,end:/&gt;/,contains:[a,i,s,r]}]}]},e.COMMENT(/&lt;!--/,/--&gt;/,{relevance:10}),{begin:/&lt;!\[CDATA\[/,end:/\]\]&gt;/,relevance:10},t,{className:"meta",begin:/&lt;\?xml/,end:/\?&gt;/,relevance:10},{className:"tag",begin:/&lt;style(?=\s|&gt;)/,end:/&gt;/,keywords:{name:"style"},contains:[o],starts:{end:/&lt;\/style&gt;/,returnEnd:!0,subLanguage:["css","xml"]}},{className:"tag",begin:/&lt;script(?=\s|&gt;)/,end:/&gt;/,keywords:{name:"script"},contains:[o],starts:{end:/&lt;\/script&gt;/,returnEnd:!0,subLanguage:["javascript","handlebars","xml"]}},{className:"tag",begin:/&lt;&gt;|&lt;\/&gt;/},{className:"tag",begin:O(/&lt;/,k(O(n,d(/\/&gt;/,/&gt;/,/\s/)))),end:/\/?&gt;/,contains:[{className:"name",begin:n,relevance:0,starts:o}]},{className:"tag",begin:O(/&lt;\//,k(O(n,/&gt;/))),contains:[{className:"name",begin:n,relevance:0},{begin:/&gt;/,relevance:0,endsParent:!0}]}]}}</span>,grmr_markdown:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >{begin:/&lt;\/?[A-Za-z_]/,end:"&gt;",subLanguage:"xml",relevance:0},</span>t=<span class="cstat-no" title="statement not covered" >{variants:[{begin:/\[.+?\]\[.*?\]/,relevance:0},{begin:/\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,relevance:2},{begin:O(/\[.+?\]\(/,/[A-Za-z][A-Za-z0-9+.-]*/,/:\/\/.*?\)/),relevance:2},{begin:/\[.+?\]\([./?&amp;#].*?\)/,relevance:1},{begin:/\[.+?\]\(.*?\)/,relevance:0}],returnBegin:!0,contains:[{className:"string",relevance:0,begin:"\\[",end:"\\]",excludeBegin:!0,returnEnd:!0},{className:"link",relevance:0,begin:"\\]\\(",end:"\\)",excludeBegin:!0,excludeEnd:!0},{className:"symbol",relevance:0,begin:"\\]\\[",end:"\\]",excludeBegin:!0,excludeEnd:!0}]};</span>const a=<span class="cstat-no" title="statement not covered" >{className:"strong",contains:[],variants:[{begin:/_{2}/,end:/_{2}/},{begin:/\*{2}/,end:/\*{2}/}]},</span>i=<span class="cstat-no" title="statement not covered" >{className:"emphasis",contains:[],variants:[{begin:/\*(?!\*)/,end:/\*/},{begin:/_(?!_)/,end:/_/,relevance:0}]};<span class="cstat-no" title="statement not covered" ></span>a.contains.push(i),i.contains.push(a);l</span>et r=<span class="cstat-no" title="statement not covered" >[n,t];<span class="cstat-no" title="statement not covered" ></span>a.contains=a.contains.concat(r),i.contains=i.contains.concat(r);v</span>ar s=<span class="cstat-no" title="statement not covered" >{className:"section",variants:[{begin:"^#{1,6}",end:"$",contains:r=r.concat(a,i)},{begin:"(?=^.+?\\n[=-]{2,}$)",contains:[{begin:"^[=-]*$"},{begin:"^",end:"\\n",contains:r}]}]},</span>o=<span class="cstat-no" title="statement not covered" >{className:"quote",begin:"^&gt;\\s+",contains:r,end:"$"};<span class="cstat-no" title="statement not covered" ></span>return{name:"Markdown",aliases:["md","mkdown","mkd"],contains:[s,n,{className:"bullet",begin:"^[ \t]*([*+-]|(\\d+\\.))(?=\\s+)",end:"\\s+",excludeEnd:!0},a,i,o,{className:"code",variants:[{begin:"(`{3,})[^`](.|\\n)*?\\1`*[ ]*"},{begin:"(~{3,})[^~](.|\\n)*?\\1~*[ ]*"},{begin:"```",end:"```+[ ]*$"},{begin:"~~~",end:"~~~+[ ]*$"},{begin:"`.+?`"},{begin:"(?=^( {4}|\\t))",contains:[{begin:"^( {4}|\\t)",end:"(\\n)$"}],relevance:0}]},{begin:"^[-\\*]{3,}",end:"$"},t,{begin:/^\[[^\n]+\]:/,returnBegin:!0,contains:[{className:"symbol",begin:/\[/,end:/\]/,excludeBegin:!0,excludeEnd:!0},{className:"link",begin:/:\s*/,end:/$/,excludeBegin:!0}]}]}}</span>,grmr_plaintext:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{name:"Plain text",aliases:["text","txt"],disableAutodetect:!0}}</span>,grmr_shell:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{name:"Shell Session",aliases:["console","shellsession"],contains:[{className:"meta",begin:/^\s{0,3}[/~\w\d[\]()@-]*[&gt;%$#][ ]?/,starts:{end:/[^\\](?=\s*$)/,subLanguage:"bash"}}]}}</span>,grmr_typescript:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >R;v</span>ar n=<span class="cstat-no" title="statement not covered" >{$pattern:R,keyword:ae.concat(["type","namespace","typedef","interface","public","private","protected","implements","declare","abstract","readonly"]),literal:ie,built_in:ce.concat(["any","void","number","boolean","string","object","never","enum"]),"variable.language":le},</span>t=<span class="cstat-no" title="statement not covered" >{className:"meta",begin:"@[A-Za-z$_][0-9A-Za-z$_]*"},</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,n,t)=&gt;{var a=<span class="cstat-no" title="statement not covered" >e.contains.findIndex(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.label===n)</span>;<span class="cstat-no" title="statement not covered" ></span>if(-1===a)<span class="cstat-no" title="statement not covered" >throw new Error("can not find mode to replace");<span class="cstat-no" title="statement not covered" >e</span></span>.contains.splice(a,1,t)}</span>;</span>const i=<span class="cstat-no" title="statement not covered" >de(e),</span>r=(<span class="cstat-no" title="statement not covered" >Object.assign(i.keywords,n),i.exports.PARAMS_CONTAINS.push(t),i.contains=i.contains.concat([t,{beginKeywords:"namespace",end:/\{/,excludeEnd:!0},{beginKeywords:"interface",end:/\{/,excludeEnd:!0,keywords:"interface extends"}]),a(i,"shebang",e.SHEBANG()),a(i,"use_strict",{className:"meta",relevance:10,begin:/^\s*['"]use strict['"]/}),i.contains.find(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"func.def"===e.label)</span>)</span>;<span class="cstat-no" title="statement not covered" >return r.relevance=0,Object.assign(i,{name:"TypeScript",aliases:["ts","tsx"]}),i}</span>,grmr_yaml:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >"true false yes no null",</span>t=<span class="cstat-no" title="statement not covered" >"[\\w#;/?:@&amp;=+$,.~*'()[\\]]+",</span>a=<span class="cstat-no" title="statement not covered" >{className:"string",relevance:0,variants:[{begin:/'/,end:/'/},{begin:/"/,end:/"/},{begin:/\S+/}],contains:[e.BACKSLASH_ESCAPE,{className:"template-variable",variants:[{begin:/\{\{/,end:/\}\}/},{begin:/%\{/,end:/\}/}]}]},</span>i=<span class="cstat-no" title="statement not covered" >e.inherit(a,{variants:[{begin:/'/,end:/'/},{begin:/"/,end:/"/},{begin:/[^\s,{}[\]]+/}]});</span>const r=<span class="cstat-no" title="statement not covered" >{end:",",endsWithParent:!0,excludeEnd:!0,keywords:n,relevance:0};</span>var s=<span class="cstat-no" title="statement not covered" >{begin:/\{/,end:/\}/,contains:[r],illegal:"\\n",relevance:0},</span>o=<span class="cstat-no" title="statement not covered" >{begin:"\\[",end:"\\]",contains:[r],illegal:"\\n",relevance:0};</span>const l=<span class="cstat-no" title="statement not covered" >[...t=[{className:"attr",variants:[{begin:"\\w[\\w :\\/.-]*:(?=[ \t]|$)"},{begin:'"\\w[\\w :\\/.-]*":(?=[ \t]|$)'},{begin:"'\\w[\\w :\\/.-]*':(?=[ \t]|$)"}]},{className:"meta",begin:"^---\\s*$",relevance:10},{className:"string",begin:"[\\|&gt;]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"},{begin:"&lt;%[%=-]?",end:"[%-]?%&gt;",subLanguage:"ruby",excludeBegin:!0,excludeEnd:!0,relevance:0},{className:"type",begin:"!\\w+!"+t},{className:"type",begin:"!&lt;"+t+"&gt;"},{className:"type",begin:"!"+t},{className:"type",begin:"!!"+t},{className:"meta",begin:"&amp;"+e.UNDERSCORE_IDENT_RE+"$"},{className:"meta",begin:"\\*"+e.UNDERSCORE_IDENT_RE+"$"},{className:"bullet",begin:"-(?=[ ]|$)",relevance:0},e.HASH_COMMENT_MODE,{beginKeywords:n,keywords:{literal:n}},{className:"number",begin:"\\b[0-9]{4}(-[0-9][0-9]){0,2}([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?(\\.[0-9]*)?([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\\b"},{className:"number",begin:e.C_NUMBER_RE+"\\b",relevance:0},s,o,a]];<span class="cstat-no" title="statement not covered" ></span>return l.pop(),l.push(i),r.contains=l,{name:"YAML",case_insensitive:!0,aliases:["yml"],contains:t}}</span>});</span>const he=<span class="cstat-no" title="statement not covered" >m;<span class="cstat-no" title="statement not covered" ></span>for(const B of Object.keys(be)){var pe=<span class="cstat-no" title="statement not covered" >B.replace("grmr_","");<span class="cstat-no" title="statement not covered" ></span>he.registerLanguage(pe,be[B])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn he}</span>();<span class="cstat-no" title="statement not covered" ></span>"object"==typeof exports&amp;&amp;"undefined"!=typeof module&amp;&amp;(module.exports=hljs);</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2023-06-11T07:01:23.233Z
            </div>
        <script src="../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../sorter.js"></script>
        <script src="../../../block-navigation.js"></script>
    </body>
</html>
    